var debug;
if (process.env.NODEFLY_DEBUG && /socket/.test(process.env.NODEFLY_DEBUG)) {
	debug = function(x) { console.error('    SOCKET: %s', x); };
} else {
	debug = function() { };
}

var io = require('socket.io-client');
var config = global.nodeflyConfig;

var socket;
var sid;

var MIN_BACKOFF = 500;
var MAX_BACKOFF = 1000*60; // 1 min
var backoff = MIN_BACKOFF;

function startSocket(url) {
	if (socket) socket.disconnect();
	socket = io.connect(url, {
		'force new connection':true,
		'max reconnection attempts': Infinity,
		//'reconnection delay': 500,
		'reconnection limit': 1000*60
	});
}

function bindEvents(options) {
	var agent = options.agent;
	var agentVersion = options.agentVersion;
	
	socket.on('connect', function(data) {
		backoff = MIN_BACKOFF;
		agent.sessionId = null;
		sid = socket.socket.sessionid;

		//console.log('[%s] connected', sid);
		
		socket.emit('createSession',{
			hostname: agent.hostname,
			appName: agent.appName,
			key: agent.key,
			agentVersion: agentVersion
		});
	});


	socket.on('newSession', function(data) {
		//console.log('[%s] newSession', sid);
		agent.sessionId = data.sessionId;
		agent.appHash = data.appHash;
	});

	socket.on('error', function(err, other) {
		if (typeof err === 'string' && err.match(/ECONNREFUSED/)) {
			console.log('Could not connect to NodeFly.  Trying again in %d seconds', backoff/1000);
			setTimeout(function() {
				startSocket(config.server);
				bindEvents(options);

				if (backoff*2 >= MAX_BACKOFF) backoff = MAX_BACKOFF;
				else backoff *= 2;
			}, backoff);
		}
		else {
			console.log('[%s] SocketIO threw error:\n', sid, err.message || JSON.stringify(err));
			if (err.stack) console.log('stack:\n', err.stack);
		}
	});
}

module.exports.init = function(options) {
	startSocket(config.server)
	bindEvents(options);
	return {
		emit: function(){
			try {
				debug('transport isOpen: ' + socket.socket.transport.isOpen);
				if (socket.socket.transport && socket.socket.transport.websocket)
					debug('websocket readyState: ' + socket.socket.transport.websocket.readyState);

				if (socket.socket.transport && socket.socket.transport.isOpen)
					socket.emit.apply(socket,arguments)
			}
			catch(err) {
				// pass thrown errors to error handler
				socket.emit('error', err);
			}
		}
	}
};
